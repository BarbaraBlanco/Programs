#include <stdio.h>
#include <stdlib.h>

// Definição da estrutura de um nó da árvore AVL
typedef struct Produto {
    int codigo;          // Código único do produto (identificador)
    int quantidade;      // Quantidade em estoque do produto
    int altura;          // Altura do nó (importante para balanceamento)
    struct Produto *esq; // Ponteiro para o filho esquerdo
    struct Produto *dir; // Ponteiro para o filho direito
} Produto;

// Função para calcular a altura de um nó
// A altura de um nó é 0 quando o nó é NULL, e 1 mais o maior valor entre a altura da subárvore esquerda ou direita.
int altura(Produto *no) {
    if (no == NULL)
        return 0;  // Se o nó for NULL, a altura é 0
    return no->altura;  // Caso contrário, retorna a altura armazenada no nó
}

// Função para calcular o fator de balanceamento de um nó
// O fator de balanceamento é a diferença entre a altura da subárvore esquerda e direita.
int fator_balanceamento(Produto *no) {
    if (no == NULL)
        return 0;  // Se o nó for NULL, o fator de balanceamento é 0
    return altura(no->esq) - altura(no->dir);  // Retorna a diferença entre as alturas das subárvores esquerda e direita
}

// Função para atualizar a altura de um nó
// A altura de um nó é 1 mais o maior valor entre as alturas de seus filhos esquerdo e direito.
void atualizar_altura(Produto *no) {
    if (no != NULL) {
        int altura_esq = altura(no->esq);  // Altura da subárvore esquerda
        int altura_dir = altura(no->dir);  // Altura da subárvore direita
        no->altura = (altura_esq > altura_dir ? altura_esq : altura_dir) + 1;  // Atualiza a altura do nó
    }
}

// Rotação à direita: Usada para balancear a árvore quando o fator de balanceamento da subárvore esquerda é 2 (desbalanceada à esquerda)
Produto* rotacao_direita(Produto *y) {
    Produto *x = y->esq;     // O nó da esquerda se torna a nova raiz
    Produto *T2 = x->dir;    // O filho direito de x é movido para o filho esquerdo de y

    // Realiza a rotação
    x->dir = y;              // A subárvore de y (filho direito) passa a ser a subárvore esquerda de x
    y->esq = T2;             // O filho direito de x (se houver) passa a ser o filho esquerdo de y

    // Atualiza as alturas
    atualizar_altura(y);  // A altura de y precisa ser recalculada após a rotação
    atualizar_altura(x);  // A altura de x também é recalculada após a rotação

    return x;  // Retorna o novo nó raiz (x)
}

// Rotação à esquerda: Usada para balancear a árvore quando o fator de balanceamento da subárvore direita é -2 (desbalanceada à direita)
Produto* rotacao_esquerda(Produto *x) {
    Produto *y = x->dir;    // O nó da direita se torna a nova raiz
    Produto *T2 = y->esq;   // O filho esquerdo de y é movido para o filho direito de x

    // Realiza a rotação
    y->esq = x;             // A subárvore de x (filho esquerdo) passa a ser a subárvore direita de y
    x->dir = T2;            // O filho esquerdo de y (se houver) passa a ser o filho direito de x

    // Atualiza as alturas
    atualizar_altura(x);  // A altura de x precisa ser recalculada após a rotação
    atualizar_altura(y);  // A altura de y também é recalculada após a rotação

    return y;  // Retorna o novo nó raiz (y)
}

// Rotação dupla à esquerda-direita: Caso em que a subárvore esquerda de um nó está desbalanceada à direita
Produto* rotacao_esquerda_direita(Produto *z) {
    z->esq = rotacao_esquerda(z->esq);  // Primeiramente, realiza uma rotação à esquerda na subárvore esquerda
    return rotacao_direita(z);          // Depois, realiza a rotação à direita no nó z
}

// Rotação dupla à direita-esquerda: Caso em que a subárvore direita de um nó está desbalanceada à esquerda
Produto* rotacao_direita_esquerda(Produto *z) {
    z->dir = rotacao_direita(z->dir);   // Primeiramente, realiza uma rotação à direita na subárvore direita
    return rotacao_esquerda(z);         // Depois, realiza a rotação à esquerda no nó z
}

// Função para inserir um novo produto na árvore AVL
Produto* inserir(Produto *no, int codigo, int quantidade) {
    // Passo 1: Inserção normal em uma árvore binária de busca
    if (no == NULL) {
        Produto *novo_produto = (Produto*)malloc(sizeof(Produto));  // Cria um novo nó
        novo_produto->codigo = codigo;  // Atribui o código do produto
        novo_produto->quantidade = quantidade;  // Atribui a quantidade em estoque
        novo_produto->esq = novo_produto->dir = NULL;  // Inicializa as subárvores como NULL
        novo_produto->altura = 1;  // O novo nó tem altura 1
        return novo_produto;  // Retorna o novo nó inserido
    }

    // Passo 2: Inserção recursiva: Se o código for menor que o código do nó atual, insere à esquerda, senão à direita
    if (codigo < no->codigo) {
        no->esq = inserir(no->esq, codigo, quantidade);
    } else if (codigo > no->codigo) {
        no->dir = inserir(no->dir, codigo, quantidade);
    } else {
        // Se o produto já existir, atualiza a quantidade
        no->quantidade += quantidade;
        return no;
    }

    // Passo 3: Atualizar a altura do nó após a inserção
    atualizar_altura(no);

    // Passo 4: Verificar o fator de balanceamento e corrigir se necessário (com rotações)
    int fb = fator_balanceamento(no);

    // Caso 1: Desbalanceamento à esquerda
    if (fb > 1 && codigo < no->esq->codigo) {
        return rotacao_direita(no);  // Realiza rotação à direita para balancear
    }

    // Caso 2: Desbalanceamento à direita
    if (fb < -1 && codigo > no->dir->codigo) {
        return rotacao_esquerda(no);  // Realiza rotação à esquerda para balancear
    }

    // Caso 3: Desbalanceamento à esquerda-direita
    if (fb > 1 && codigo > no->esq->codigo) {
        return rotacao_esquerda_direita(no);  // Realiza rotação dupla à esquerda-direita
    }

    // Caso 4: Desbalanceamento à direita-esquerda
    if (fb < -1 && codigo < no->dir->codigo) {
        return rotacao_direita_esquerda(no);  // Realiza rotação dupla à direita-esquerda
    }

    // Retorna o nó, agora balanceado
    return no;
}

// Função para remover um produto da árvore AVL
Produto* remover(Produto *no, int codigo) {
    if (no == NULL)  // Se o nó for NULL, significa que o produto não foi encontrado
        return no;

    // Passo 1: Realiza a remoção como em uma árvore binária de busca
    if (codigo < no->codigo) {
        no->esq = remover(no->esq, codigo);  // Se o código for menor, busca à esquerda
    } else if (codigo > no->codigo) {
        no->dir = remover(no->dir, codigo);  // Se o código for maior, busca à direita
    } else {
        // Passo 2: Encontramos o produto a ser removido
        if (no->esq == NULL || no->dir == NULL) {
            Produto *temp = no->esq ? no->esq : no->dir;  // Se um dos filhos for NULL, o nó é substituído pelo filho não-nulo
            if (temp == NULL) {
                temp = no;  // Se o nó não tiver filhos, o nó é removido
                no = NULL;
            } else {
                *no = *temp;  // Caso contrário, copia o conteúdo do nó não-nulo para o nó a ser removido
            }
            free(temp);  // Libera a memória do nó removido
        } else {
            // Caso 3: O nó tem dois filhos, precisa encontrar o sucessor (menor valor da subárvore direita)
            Produto *temp = no->dir;
            while (temp->esq != NULL) {
                temp = temp->esq;
            }
            no->codigo = temp->codigo;  // Copia o código do sucessor
            no->quantidade = temp->quantidade;  // Copia a quantidade do sucessor
            no->dir = remover(no->dir, temp->codigo);  // Remove o sucessor
        }
    }

    // Passo 3: Se a árvore não está vazia, atualiza a altura do nó atual
    if (no == NULL)
        return no;

    atualizar_altura(no);

    // Passo 4: Verifica e corrige o balanceamento após a remoção
    int fb = fator_balanceamento(no);

    // Caso 1: Desbalanceamento à esquerda
    if (fb > 1 && fator_balanceamento(no->esq) >= 0) {
        return rotacao_direita(no);
    }

    // Caso 2: Desbalanceamento à direita
    if (fb < -1 && fator_balanceamento(no->dir) <= 0) {
        return rotacao_esquerda(no);
    }

    // Caso 3: Desbalanceamento à esquerda-direita
    if (fb > 1 && fator_balanceamento(no->esq) < 0) {
        return rotacao_esquerda_direita(no);
    }

    // Caso 4: Desbalanceamento à direita-esquerda
    if (fb < -1 && fator_balanceamento(no->dir) > 0) {
        return rotacao_direita_esquerda(no);
    }

    return no;
}

// Função para buscar um produto na árvore
Produto* buscar(Produto *no, int codigo) {
    if (no == NULL || no->codigo == codigo)  // Se o nó for NULL ou o código for encontrado
        return no;
    
    if (codigo < no->codigo)  // Se o código for menor, busca à esquerda
        return buscar(no->esq, codigo);
    else  // Se o código for maior, busca à direita
        return buscar(no->dir, codigo);
}

// Função para listar todos os produtos da árvore em ordem crescente
void listar_em_ordem(Produto *no) {
    if (no != NULL) {
        listar_em_ordem(no->esq);  // Primeiro, lista a subárvore esquerda
        printf("Produto: %d - Quantidade: %d\n", no->codigo, no->quantidade);  // Exibe o código e quantidade
        listar_em_ordem(no->dir);  // Depois, lista a subárvore direita
    }
}

// Função para liberar toda a memória da árvore
void liberar_memoria(Produto *no) {
    if (no != NULL) {
        liberar_memoria(no->esq);  // Libera a subárvore esquerda
        liberar_memoria(no->dir);  // Libera a subárvore direita
        free(no);  // Libera o nó atual
    }
}

// Função principal que exibe o menu e interage com o usuário
int main() {
    Produto *estoque = NULL;  // A árvore AVL começa vazia

    int opcao, codigo, quantidade;

    while (1) {
        printf("\nMenu:\n");
        printf("1. Inserir produto\n");
        printf("2. Remover produto\n");
        printf("3. Buscar produto\n");
        printf("4. Listar produtos em ordem\n");
        printf("5. Sair\n");
        printf("Escolha uma opção: ");
        scanf("%d", &opcao);

        switch (opcao) {
            case 1:
                printf("Digite o código do produto: ");
                scanf("%d", &codigo);
                printf("Digite a quantidade em estoque: ");
                scanf("%d", &quantidade);
                estoque = inserir(estoque, codigo, quantidade);
                printf("Produto inserido com sucesso!\n");
                break;
            case 2:
                printf("Digite o código do produto a ser removido: ");
                scanf("%d", &codigo);
                estoque = remover(estoque, codigo);
                printf("Produto removido com sucesso!\n");
                break;
            case 3:
                printf("Digite o código do produto a ser buscado: ");
                scanf("%d", &codigo);
                Produto *prod = buscar(estoque, codigo);
                if (prod != NULL) {
                    printf("Produto encontrado! Quantidade: %d\n", prod->quantidade);
                } else {
                    printf("Produto não encontrado.\n");
                }
                break;
            case 4:
                printf("Lista de Produtos em Ordem:\n");
                listar_em_ordem(estoque);
                break;
            case 5:
                // Libera toda a memória alocada antes de sair
                liberar_memoria(estoque);
                printf("Saindo do programa.\n");
                return 0;
            default:
                printf("Opção inválida!\n");
        }
    }

    return 0;
}

Explicação das Funções de Gerenciamento de Memória:

Alocação de memória: Durante a inserção de um novo produto, é feito o malloc para alocar um novo nó.

Liberação de memória: Quando um produto é removido, a memória do nó removido é liberada com free(). A função liberar_memoria percorre a árvore recursivamente e libera a memória de todos os nós.

Finalização do programa: A função liberar_memoria é chamada ao final do programa para garantir que toda a memória alocada seja devidamente liberada.

Estrutura de Dados: Cada nó contém o código do produto, a quantidade em estoque, a altura (usada para verificar balanceamento) e ponteiros para os filhos esquerdo e direito.


Balanceamento:

Rotação à direita e à esquerda são usadas quando a árvore está desbalanceada em uma direção.

Rotações duplas (à esquerda-direita e à direita-esquerda) são necessárias quando o desbalanceamento ocorre de forma diagonal.

Como testar:

Inserção de Produtos: Escolha a opção 1 para inserir novos produtos.

Remoção de Produtos: Use a opção 2 para remover produtos.

Busca de Produtos: A opção 3 permite buscar produtos por código.

Listagem em Ordem: A opção 4 lista os produtos na ordem crescente de seus códigos.

Saída: A opção 5 finaliza o programa e libera toda a memória.